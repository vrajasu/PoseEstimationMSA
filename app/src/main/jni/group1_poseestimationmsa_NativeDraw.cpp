/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
#include <group1_poseestimationmsa_NativeDraw.h>
#include <android/log.h>
#include <algorithm>
#include <opencv2/opencv.hpp>
#include <android/native_window.h>
#include <android/native_window_jni.h>


#define LOGE(...) __android_log_print(ANDROID_LOG_ERROR, "sampleMSRS", __VA_ARGS__)



using namespace cv;
using namespace std;



JNIEXPORT jstring JNICALL Java_group1_poseestimationmsa_NativeDraw_getHello
  (JNIEnv *, jclass){

}
JNIEXPORT void JNICALL
Java_group1_poseestimationmsa_NativeDraw_drawNative(JNIEnv *env, jclass type, jint width,
                                                    jint height, jobject buffer, jobject surface) {

    uint8_t *srcLumaPtr = reinterpret_cast<uint8_t *>(env->GetDirectBufferAddress(buffer));

    int dstWidth;
    int dstHeight;

    cv::Mat mYuv(height + height / 2, width, CV_8UC1, srcLumaPtr);


    ANativeWindow *win = ANativeWindow_fromSurface(env, surface);
    ANativeWindow_acquire(win);

    ANativeWindow_Buffer buf;
    //
    dstWidth = height;
    dstHeight = width;

    ANativeWindow_setBuffersGeometry(win, dstWidth, dstHeight, 0 /*format unchanged*/);


    if (int32_t err = ANativeWindow_lock(win, &buf, NULL)) {
        LOGE("ANativeWindow_lock failed with error code %d\n", err);
        ANativeWindow_release(win);
        return ;
    }

    uint8_t *dstLumaPtr = reinterpret_cast<uint8_t *>(buf.bits);

    Mat dstRgba(dstHeight, buf.stride, CV_8UC4,
                dstLumaPtr);        // TextureView buffer, use stride as width
    Mat srcRgba(height, width, CV_8UC4);
    Mat flipRgba(dstHeight, dstWidth, CV_8UC4);

    // convert YUV -> RGBA
    cv::cvtColor(mYuv, srcRgba, CV_YUV2RGBA_NV21);

    // Rotate 90 degree
    cv::transpose(srcRgba, flipRgba);
    cv::flip(flipRgba, flipRgba,1);// negative parameter indicates flipping on both axes. 0- flipping on y-axis and 1- splitting on x-axis.

    // copy to TextureView surface
    uchar *dbuf;
    uchar *sbuf;
    dbuf = dstRgba.data;
    sbuf = flipRgba.data;
    int i;
    for (i = 0; i < flipRgba.rows; i++) {
        dbuf = dstRgba.data + i * buf.stride * 4;
        memcpy(dbuf, sbuf, flipRgba.cols*4);
        sbuf += flipRgba.cols * 4;
    }


    ANativeWindow_unlockAndPost(win);
    ANativeWindow_release(win);

}


